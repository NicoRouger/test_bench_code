# Open Power Tuesday - v1.2
# Nov 14th 2024
# Author: Nicolas ROUGER, Luiz VILLA, Joseph KEMDENG, Pauline KERGUS, Matthieu MASSON
#
# Joint effort: LAPLACE + LAAS + Owntech -- thanks to all other contributors!
#
# Minor edit, cleaning and added functions v1.2
# License: GPL 3.0
#
# PURPOSE:
# Opposition method // control and measure 2 half bridges in opposition method
# for losses measurement.
#
# Supervisor to control:
#   1) microcontroller (Spin board from Owntech)
#   2) Power supply
#   3) Digital Multimeter (DMM)
#
# Test sequence is:
#   1) Config microcontroller and turn ON gate signal
#   2) Start logging DC current at DMM
#   3) Sweep DC bus Voltage (ramp up)
#   4) Sweep Phase Shift generated by microcontroller (ramp up and down)
#   5) Ramp down DC bus Voltage
#   6) Read Buffer of DMM
#   7) Plot and export data in .csv with timestamp
#   8) Return to initial state
# -------------------------------------------------
#
# REQUIREMENTS:
# SPIN must be loaded with v1.0.0-rc-power_tuesday branch
# The python files with key functions for SPIN must be copied in the "comm_protocol" folder
#   > The folder is located in the cloned GIT repo. at owntech\lib\USB\comm_protocol
# The DMM used is SDM3065 from Siglent
# The power supply used is Z650+ from TDK Lambda
# Do not forget to add the address of DMM and powersupply!!!! Can use def list_instruments(): if needed
# -------------------------------------------------

import serial
import os
import sys
parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../"))
sys.path.insert(0, parent_dir)


from comm_protocol.src import find_devices
from comm_protocol.src.Shield_Class import Shield_Device

import matplotlib.pyplot as plt
import matplotlib.animation as animation

import xmlrpc.client as xml
import time
import matplotlib.pyplot as plt
import numpy as np


import os
from matplotlib import pyplot as plt
import pyvisa as visa
from pyvisa import constants
from pyvisa.resources.serial import SerialInstrument
#from pymeasure.instruments.keithley import Keithley2400, Keithley2600

import math
from datetime import datetime


delay = 0.1 #delay in seconds (100 ms)
delay2 = 0.2 #delay in seconds (200 ms)

#---------------------- Useful Functions
def PlotValues(data):
    x=data.split(",")
    dataFormatted=[float(i) for i in x]
    plt.plot(dataFormatted)
    plt.ylabel('current')
    plt.show()

# ------------ Identification of instruments
def list_instruments():
    rm = visa.ResourceManager()
    instrument_list = rm.list_resources()

    for instrument in instrument_list:
        print("'{:s}': ".format(instrument), end=' ')
        try:
            device = rm.open_resource(instrument)
            print(type(device), end=' ')
            print(device.query("*IDN?"), end='\n')

        except visa.errors.VisaIOError:
            print('INSTRUMENT ERROR\n')


# ------------ Functions for DMM
def GetBuffer(dmm):
    cmd0 = 'FETCh?'
    time.sleep(4) # 4 second delay to be sure previous measurement is OK
    resultString=str(dmm.query(cmd0))
    time.sleep(2) # DELAY as a function of number of DATA!!!!!
    print(resultString)
    return resultString



def ConfigForDCCurrentMeasureAndStoreBuffer(dmm):
    cmd1 = 'CONF:CURR:DC AUTO' # Auto range
    cmd2 = 'TRIG:COUN 1' # 1 trigger
    cmd3 = 'TRIG:SOUR IMM' # Immediate trig, whenever INIT would be sent
    cmd4 = 'SAMP:COUN 1000' # 1000 measurements
    cmd5 = 'CURR:DC:NPLC 1' # NPLC 1
    cmd6 = 'CURR:DC:AZ OFF' # Autozero OFF
    #cmd7 = 'TRIG:DEL 1 ' #1 sec delay between each measurement
    cmd7 = 'TRIG:DEL:AUTO ' #auto delay between each measurement
    dmm.write(cmd2)
    time.sleep(delay)
    dmm.write(cmd3)
    time.sleep(delay)
    dmm.write(cmd4)
    time.sleep(delay)
    dmm.write(cmd5)
    time.sleep(delay)
    dmm.write(cmd6)
    time.sleep(delay)
    dmm.write(cmd7)
    time.sleep(delay)


def TimeStamp():
    now = datetime.now()
    day = now.strftime("%d_%m_%Y")
    current_time = now.strftime("%H_%M_%S")
    print("Current Time =", current_time,day)
    return current_time+'-'+day

def StartCurrentMeasureAndStoreBufferDC(dmm):
    cmd8 = 'INIT' # Initiate measurement if Trigger immediate is set before
    DayAndHour=TimeStamp()
    dmm.write(cmd8)
    time.sleep(delay)
    return DayAndHour
 

def MeasureCurrentDC(dmm): # Configure, Ask for measurement and Read buffer at the same time
    cmd1 = 'CONF:CURR:DC AUTO'
    cmd2 = 'TRIG:COUN 10'
    cmd3 = 'TRIG:SOUR IMM'
    cmd4 = 'SAMP:COUN 2'
    cmd5 = 'CURR:DC:NPLC 0.5'
    #cmd6 = 'MEAS:VOLT:DC AUTO'
    cmd6 = 'CURR:DC:AZ OFF'
    #cmd7 = 'TRIG:DEL 1 ' #1 sec delay between each measurement
    cmd7 = 'TRIG:DEL:AUTO ' #auto delay between each measurement
    cmd8 = 'READ?'
    #cmd8 = 'MEAS:VOLT:DC? AUTO'
    dmm.write(cmd1)
    time.sleep(delay)
    dmm.write(cmd2)
    time.sleep(delay)
    dmm.write(cmd3)
    time.sleep(delay)
    dmm.write(cmd4)
    time.sleep(delay)
    dmm.write(cmd5)
    time.sleep(delay)
    dmm.write(cmd6)
    time.sleep(delay)
    dmm.write(cmd7)
    time.sleep(delay)
    resultString=str(dmm.query(cmd8))
    time.sleep(4) # DELAY as a function of number of DATA!!!!!
    print(resultString)
    return resultString

def ExportResultToCSV(String,TimeInfo):
    f = open('csv-'+TimeInfo+'.csv','w')
    f.write(String) #Give your csv text here.
    ## Python will convert \n to os.linesep
    f.close()

def StartLoggingDCcurrent():
    #print(args)
    rm = visa.ResourceManager()
    #SDM3065 in USB! INPUT YOUR INSTRUMENT HERE!!!!
    DMM3065 = rm.open_resource('USB0::XXXXXXXXXX::INSTR', query_delay=0.5)

    # Configure, Send Measurement request and get value
    #Voltage = MeasureVoltageDC(DMM3065)

    #First ask to measure then fetch memory
    ConfigForDCCurrentMeasureAndStoreBuffer(DMM3065) # Config
    DayAndHour = StartCurrentMeasureAndStoreBufferDC(DMM3065) # Measure and Store in buffer
    #Current = GetBuffer(DMM3065) # Read buffer
    rm.close()
    time.sleep(delay)
    return DayAndHour

    #Save data to CSV
    #ExportResultToCSV(Current,DayAndHour)
    
    #rm.visalib._registry.clear()

def ReadBufferCurrent(DayAndHour):
    rm = visa.ResourceManager()
    #SDM3065 in USB!
    #SDM3065 in USB! INPUT YOUR INSTRUMENT HERE!!!!
    DMM3065 = rm.open_resource('USB0::XXXXXXXXXX::INSTR', query_delay=0.5)

    # Configure, Send Measurement request and get value
    #Voltage = MeasureVoltageDC(DMM3065)

    #First ask to measure then fetch memory
    Current = GetBuffer(DMM3065) # Read buffer
    rm.close()
    time.sleep(delay)

    #Save data to CSV
    ExportResultToCSV(Current,DayAndHour)

    # Plot data
    PlotValues(Current)
    
    #rm.visalib._registry.clear()
    
# ------------------ End functions DMM




# ------------------- Functions OWNTECH Spin
def SweepPhaseShift(Board,PhaseInit,PhaseFinal,step):
    
    for phase_shift_value in range(PhaseInit, PhaseFinal, step):  # Example values from 0 to 170 with a step of 10
      message1 = Board.sendCommand("PHASE_SHIFT", "LEG2", phase_shift_value)
      print(f"Sent command with phase shift: {phase_shift_value}, message: {message1}")

    for phase_shift_value_down in range(PhaseFinal, PhaseInit, -step):  # Example values from 0 to 170 with a step of 10
      message1 = Board.sendCommand("PHASE_SHIFT", "LEG2", phase_shift_value_down)
      print(f"Sent command with phase shift: {phase_shift_value_down}, message: {message1}")




# -----------------Functions for POWER SUPPLY (TDK Lambda Z+)
    
def OutputChange(smu,State):
    cmd1 = 'OUTPut:STATe '+State
    smu.write(cmd1)
    time.sleep(delay)
    

def VoltageShutDown(source,voltage,VoltageLimit):
    if float(voltage) >= VoltageLimit:
        OutputChange(source,'OFF')
    time.sleep(delay)
    
def CurrentShutDown(source,current,CurrentLimit):
    if float(current) >= CurrentLimit:
        OutputChange(source,'OFF')
    time.sleep(delay)

def VoltageRampUp(source,voltage,delay):
    cmd1 = 'VOLTage:MODE FIX'
    source.write(cmd1)
    x = 0
    for x in range(0,voltage,1):
        if x <= voltage:
            cmd2 = 'VOLTage:LEV '+str(x)
            source.write(cmd2)
            time.sleep(delay)
    time.sleep(delay)
    SweepPhaseShift(Board,PhaseInit,PhaseFinal,step)

def VoltageRampUpAndSweepPhase(source,voltage,delay,Board,PhaseInit,PhaseFinal,step):
    cmd1 = 'VOLTage:MODE FIX'
    source.write(cmd1)
    time.sleep(delay2)
    x = 0
    for x in range(0,voltage,2): # SWEEP DC Voltage for RAMP UP
        if x <= voltage:
            cmd2 = 'VOLTage:LEV '+str(x)
            source.write(cmd2)
            time.sleep(delay2)
    time.sleep(delay2)
    SweepPhaseShift(Board,PhaseInit,PhaseFinal,step) # SWEEP PHASE SHIFT of microcontroller
    
def VoltageRampDown(source,voltage,delay, end_value = 0, step_value = -2):
    cmd1 = 'VOLTage:MODE FIX'
    source.write(cmd1)
    time.sleep(delay2)
    cmd2 = 'VOLTage:LEV '+str(voltage)
    source.write(cmd2)
    time.sleep(delay2)
    for x in  range(voltage,end_value,step_value):
        if x >= 0:
            cmd2 = 'VOLTage:LEV '+str(x)
            source.write(cmd2)
            time.sleep(delay2)
            # x=x-5
    time.sleep(delay)
    
def CheckVoltage(source):
    cmd1 = ':VOLTage?'
    result = str(source.query(cmd1))
    return(result)
    time.sleep(delay)

def CheckCurrent(source):
    cmd1 = ':CURRent?'
    result = str(source.query(cmd1))
    return(result)
    time.sleep(delay)
    

def DCSweepVoltageSource():
    #print(args)
    VoltageLimit = 100
    CurrentLimit = 0.3
    VoltageWrite = 50
    timestep = 0.1
    PhaseInit = 15
    PhaseFinal = 95
    PhaseStep = 10
    #Shield_ports = find_devices.find_shield_device_ports(shield_vid, shield_pid)
    #print(Shield_ports)
    #Shield = Shield_Device(shield_port= Shield_ports[0], shield_type='TWIST')
    
    rm = visa.ResourceManager()
    #TDK Lambda #1 in USB
    TDKLambda = rm.open_resource('ASRL27::INSTR', query_delay=0.5)
    TDKLambda.write('INSTrument:NSELect 1') # MANDATORY, at least once: Select ADDRESS prior to other functions
    '''TDKLambda.baud_rate = 9600 # 300
    TDKLambda.write_termination = ''
    TDKLambda.read_termination = '\r\n'
    TDKLambda.set_visa_attribute(constants.VI_ATTR_ASRL_FLOW_CNTRL, constants.VI_ASRL_FLOW_XON_XOFF)
    TDKLambda.stop_bits = constants.StopBits.one
    TDKLambda.parity = constants.Parity.none
    TDKLambda.data_bits = 8'''
    TDKLambda.write('VOLTage:LEV 0')
    time.sleep(0.5)
    OutputChange(TDKLambda,'ON')
    time.sleep(1)
    #VoltageRampUp(TDKLambda,VoltageWrite,timestep)
    VoltageRampUpAndSweepPhase(TDKLambda,VoltageWrite,timestep,Shield,PhaseInit,PhaseFinal,PhaseStep)
    time.sleep(1)
    #voltageRead = CheckVoltage(TDKLambda)
    #currentRead = CheckCurrent(TDKLambda)
    #print(voltageRead)
    #print(currentRead)
##    VoltageShutDown(TDKLambda,voltageRead,VoltageLimit)
##    CurrentShutDown(TDKLambda,currentRead,CurrentLimit)
    VoltageRampDown(TDKLambda,VoltageWrite,timestep)

    time.sleep(1)
    TDKLambda.write('VOLTage:LEV 0')
    time.sleep(0.5)
    OutputChange(TDKLambda,'OFF')
    time.sleep(1)
    rm.close()
    time.sleep(delay)

    
    #rm.visalib._registry.clear()

# -------------------End Functions Power Supply    



 
# -------------------Functions SPIN Owntech Microcontroller
def repeat_get_line(shield, num_times):
    """
    Calls shield.getLine() and prints the result the specified number of times.

    Args:
        shield: The object that has the getLine() method (e.g., Shield).
        num_times (int): The number of times to call getLine() and print the result.
    """
    for _ in range(num_times):
        message = shield.getLine()
        print(message)

# Example usage:
# repeat_get_line(Shield, 5)  # Calls Shield.getLine() 5 times and prints each message




# MAIN function

leg_to_test = "LEG1"                               #leg to be tested in this script
reference_names = ["V1","V2","VH","I1","I2","IH"]  #names of the sensors of the board

shield_vid = 0x2fe3
shield_pid = 0x0101

Shield_ports = find_devices.find_shield_device_ports(shield_vid, shield_pid)
print(Shield_ports)

Shield = Shield_Device(shield_port= Shield_ports[0], shield_type='TWIST')

try:

  # ---------------HARDWARE IN THE LOOP PV EMULATOR CODE ------------------------------------
##  message1 = Shield.sendCommand("IDLE")
##  print(message1)
##
##  message = Shield.sendCommand( "BUCK", "LEG1", "OFF")
##  print(message)
##
  message = Shield.sendCommand( "BUCK", "LEG2", "OFF")
  print(message)

  message = Shield.sendCommand("LEG","LEG1","ON")
  print(message)

  message = Shield.sendCommand("LEG","LEG2","ON") 
  print(message)

  message = Shield.sendCommand("POWER_ON")
  print(message)

  message = Shield.sendCommand("DUTY","LEG1",0.485) # Initial duty cycle is 48.5%, to compensate dead time
  print(message)

  message = Shield.sendCommand("DUTY","LEG2",0.485) # Initial duty cycle is 48.5%, to compensate dead time
  print(message)

##  for dead_time_value in range(100, 300, 50):  
##      message1 = Shield.sendCommand("DEAD_TIME_RISING", "LEG1", dead_time_value)
##      message1 = Shield.sendCommand("DEAD_TIME_FALLING", "LEG1", dead_time_value)
##      message1 = Shield.sendCommand("DEAD_TIME_RISING", "LEG2", dead_time_value)
##      message1 = Shield.sendCommand("DEAD_TIME_FALLING", "LEG2", dead_time_value)
##      print(f"Sent command with phase shift: {dead_time_value}, message: {message1}")

##
##  for frequency_value in range(50000, 150000, 10000):  # Example values from 0 to 170 with a step of 10
##      message1 = Shield.sendCommand("FREQUENCY", "LEG1", frequency_value)
##      print(f"Sent command with frequency: {frequency_value}, message: {message1}")

  message1 = Shield.sendCommand("FREQUENCY", "LEG1", 100000) # 100 kHz switching freq


  message = Shield.sendCommand("DEAD_TIME_RISING","LEG2",300) # 300 ns deadtime
  message = Shield.sendCommand("DEAD_TIME_RISING","LEG1",300) # 300 ns deadtime
  print(message)

  message = Shield.sendCommand("DEAD_TIME_FALLING","LEG2",300) # 300 ns deadtime
  message = Shield.sendCommand("DEAD_TIME_FALLING","LEG1",300) # 300 ns deadtime
  print(message)


  message1 = Shield.sendCommand("PHASE_SHIFT","LEG2",15) # Initial phase shift is 15Â°
  print(message1)

# ------------------------------------------
# MAIN Test sequence
#
# START LOGGING
  dayFunky=StartLoggingDCcurrent()

# Start DC Voltage SWEEP
  DCSweepVoltageSource()

# READ BUFFER
  ReadBufferCurrent(dayFunky)


##  for phase_shift_value in range(0, 170, 10):  # Example values from 0 to 170 with a step of 10
##      message1 = Shield.sendCommand("PHASE_SHIFT", "LEG2", phase_shift_value)
##      print(f"Sent command with phase shift: {phase_shift_value}, message: {message1}")
##
##  for phase_shift_value_down in range(160, 0, -10):  # Example values from 0 to 170 with a step of 10
##      message1 = Shield.sendCommand("PHASE_SHIFT", "LEG2", phase_shift_value_down)
##      print(f"Sent command with phase shift: {phase_shift_value}, message: {message1}")


##  repeat_get_line(Shield, 80)  # Calls Shield.getLine() 5 times and prints each message



# ------------------------------------------
# Return to Init PHASE and final state
#
finally:
  message1 = Shield.sendCommand("PHASE_SHIFT","LEG2",15)
  print(message1)
  print(message1)
